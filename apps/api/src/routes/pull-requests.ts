import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { eq, and, desc, sql } from 'drizzle-orm';
import type { AppContext } from '../types';
import { getDatabase } from '../lib/db';
import {
  projects,
  branches,
  pullRequests,
  prChanges,
  prRiskFlags,
} from '@codecraft/db/schema'; 
import { getGitHubToken } from '../lib/github';
import {
  createPullRequest as createGitHubPR,
  getPullRequest,
  getPullRequestFiles,
  getCheckRuns,
  getPullRequestReviews,
  mergePullRequest as mergeGitHubPR,
  updatePullRequest,
  getPullRequestComments,
  getPullRequestReviewComments,
  deleteBranch,
} from '../lib/github';

const pullRequestsRouter = new Hono<AppContext>();

// SCHEMAS

const createPRSchema = z.object({
  projectId: z.string().uuid(),
  branchId: z.string().uuid(),
  title: z.string().min(1).max(200).trim(),
  changes: z.array(
    z.object({
      path: z.string(),
      type: z.enum(['added', 'modified', 'deleted']),
      additions: z.number().int().nonnegative().optional(),
      deletions: z.number().int().nonnegative().optional(),
    })
  ),
  riskFlags: z
    .array(
      z.object({
        level: z.enum(['low', 'medium', 'high']),
        message: z.string().min(1),
        file: z.string().optional(),
      })
    )
    .optional()
    .default([]),
  agentRunId: z.string().uuid().optional(),
});

const mergePRSchema = z.object({
  mergeMethod: z.enum(['merge', 'squash', 'rebase']).default('squash'),
  commitTitle: z.string().optional(),
  commitMessage: z.string().optional(),
});

// HELPER FUNCTIONS

/**
 * Generate PR body with summary, diffs, and risk flags
 */
function generatePRBody(
  changes: any[],
  riskFlags: any[],
  agentRunId?: string
): string {
  let body = `## ðŸ¤– FactoryJet AI Changes\n\n`;

  if (agentRunId) {
    body += `**Agent Run:** \`${agentRunId}\`\n\n`;
  }

  body += `### ðŸ“ Summary\n\n`;
  body += `This PR contains ${changes.length} file(s) changed:\n\n`;
  
  const added = changes.filter((c) => c.type === 'added').length;
  const modified = changes.filter((c) => c.type === 'modified').length;
  const deleted = changes.filter((c) => c.type === 'deleted').length;

  if (added > 0) body += `- âœ… **${added}** file(s) added\n`;
  if (modified > 0) body += `- âœï¸ **${modified}** file(s) modified\n`;
  if (deleted > 0) body += `- ðŸ—‘ï¸ **${deleted}** file(s) deleted\n`;

  body += `\n### ðŸ“Š Changed Files\n\n`;
  changes.forEach((change) => {
    const icon =
      change.type === 'added' ? 'âœ…' : change.type === 'modified' ? 'âœï¸' : 'ðŸ—‘ï¸';
    body += `${icon} \`${change.path}\``;
    if (change.additions || change.deletions) {
      body += ` (+${change.additions || 0} -${change.deletions || 0})`;
    }
    body += `\n`;
  });

  if (riskFlags.length > 0) {
    body += `\n### âš ï¸ Risk Flags\n\n`;
    riskFlags.forEach((flag) => {
      const emoji =
        flag.level === 'high' ? 'ðŸ”´' : flag.level === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      body += `${emoji} **${flag.level.toUpperCase()}**: ${flag.message}`;
      if (flag.file) {
        body += ` (\`${flag.file}\`)`;
      }
      body += `\n`;
    });
  }

  body += `\n---\n\n`;
  body += `ðŸš€ Generated by [FactoryJet CMS](https://factoryjet.dev)\n`;

  return body;
}

// ROUTES - CREATE PR

/**
 * POST /pull-requests/create
 * Create a new pull request on GitHub
 */
pullRequestsRouter.post(
  '/create',
  zValidator('json', createPRSchema),
  async (c) => {
    try {
      const {
        projectId,
        branchId,
        title,
        changes,
        riskFlags,
        agentRunId,
      } = c.req.valid('json');
      const userId = c.get('userId');

      if (!userId) {
        return c.json({ error: 'Unauthorized' }, 401);
      }

      const db = getDatabase(c.env.DB);

      // Get project
      const [project] = await db
        .select()
        .from(projects)
        .where(and(
          eq(projects.id, projectId),
          eq(projects.userId, userId)
        ))
        .limit(1);

      if (!project) {
        return c.json({ error: 'Project not found' }, 404);
      }

      // Get branch
      const [branch] = await db
        .select()
        .from(branches)
        .where(and(
          eq(branches.id, branchId),
          eq(branches.projectId, projectId)
        ))
        .limit(1);

      if (!branch) {
        return c.json({ error: 'Branch not found' }, 404);
      }

      // Get GitHub token
      const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
      if (!token) {
        return c.json({ error: 'GitHub token not found' }, 401);
      }

      // Create PR on GitHub
      const prBody = generatePRBody(changes, riskFlags, agentRunId);
      const repoFullName = `${project.owner}/${project.repoName}`;

      const pr = await createGitHubPR(token, repoFullName, {
        title,
        body: prBody,
        head: branch.name,
        base: branch.baseBranch || 'main',
      });

      // Store PR in database
      const prId = crypto.randomUUID();
      const now = new Date();

      await db.insert(pullRequests).values({
        id: prId,
        projectId,
        branchId,
        githubPrNumber: pr.number,
        title,
        status: 'open',
        createdAt: now,
        updatedAt: now,
        agentRunId: agentRunId || null,
      });

      // Store changes
      const changeRecords = changes.map((change) => ({
        id: crypto.randomUUID(),
        pullRequestId: prId,
        filePath: change.path,
        changeType: change.type,
        additions: change.additions || 0,
        deletions: change.deletions || 0,
        createdAt: now,
      }));

      if (changeRecords.length > 0) {
        await db.insert(prChanges).values(changeRecords);
      }

      // Store risk flags
      const flagRecords = riskFlags.map((flag) => ({
        id: crypto.randomUUID(),
        pullRequestId: prId,
        level: flag.level,
        message: flag.message,
        filePath: flag.file || null,
        createdAt: now,
      }));

      if (flagRecords.length > 0) {
        await db.insert(prRiskFlags).values(flagRecords);
      }

      return c.json({
        success: true,
        pullRequest: {
          id: prId,
          number: pr.number,
          url: pr.html_url,
          title: pr.title,
          status: 'open',
          createdAt: now.toISOString(),
        },
      }, 201);

    } catch (error: any) {
      console.error('PR creation error:', error);
      
      if (error.message?.includes('422')) {
        return c.json({ 
          error: 'Validation failed', 
          details: error.message 
        }, 422);
      }
      
      return c.json(
        { error: 'Failed to create pull request', details: error.message },
        500
      );
    }
  }
);

// ROUTES - LIST PRs

/**
 * GET /pull-requests/:projectId
 * List all pull requests for a project
 */
pullRequestsRouter.get('/:projectId', async (c) => {
  try {
    const projectId = c.req.param('projectId');
    const userId = c.get('userId');
    const status = c.req.query('status') as 'open' | 'closed' | 'merged' | undefined;
    const limit = parseInt(c.req.query('limit') || '50');
    const offset = parseInt(c.req.query('offset') || '0');

    if (!userId) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const db = getDatabase(c.env.DB);

    // Verify project ownership
    const [project] = await db
      .select()
      .from(projects)
      .where(and(
        eq(projects.id, projectId),
        eq(projects.userId, userId)
      ))
      .limit(1);

    if (!project) {
      return c.json({ error: 'Project not found' }, 404);
    }

    // Build query
    let query = db
      .select({
        id: pullRequests.id,
        projectId: pullRequests.projectId,
        branchId: pullRequests.branchId,
        githubPrNumber: pullRequests.githubPrNumber,
        title: pullRequests.title,
        status: pullRequests.status,
        createdAt: pullRequests.createdAt,
        updatedAt: pullRequests.updatedAt,
        mergedAt: pullRequests.mergedAt,
        agentRunId: pullRequests.agentRunId,
        branchName: branches.name,
        baseBranch: branches.baseBranch,
      })
      .from(pullRequests)
      .innerJoin(branches, eq(pullRequests.branchId, branches.id))
      .where(eq(pullRequests.projectId, projectId))
      .orderBy(desc(pullRequests.createdAt))
      .limit(limit)
      .offset(offset);

    // Add status filter if provided
    if (status) {
      query = query.where(and(
        eq(pullRequests.projectId, projectId),
        eq(pullRequests.status, status)
      ));
    }

    const prs = await query;

    // Get total count
    const [countResult] = await db
      .select({ count: sql<number>`count(*)` })
      .from(pullRequests)
      .where(
        status
          ? and(eq(pullRequests.projectId, projectId), eq(pullRequests.status, status))
          : eq(pullRequests.projectId, projectId)
      );

    const total = countResult?.count || 0;

    return c.json({ 
      pullRequests: prs,
      pagination: {
        total,
        limit,
        offset,
        hasMore: total > (offset + limit)
      }
    });

  } catch (error: any) {
    console.error('Error fetching PRs:', error);
    return c.json({ error: 'Failed to fetch pull requests' }, 500);
  }
});

// ROUTES - PR STATUS

/**
 * GET /pull-requests/:prId/status
 * Get detailed PR status including checks and reviews
 */
pullRequestsRouter.get('/:prId/status', async (c) => {
  try {
    const prId = c.req.param('prId');
    const userId = c.get('userId');

    if (!userId) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const db = getDatabase(c.env.DB);

    // Get PR with project info
    const [pr] = await db
      .select({
        id: pullRequests.id,
        githubPrNumber: pullRequests.githubPrNumber,
        status: pullRequests.status,
        owner: projects.owner,
        repoName: projects.repoName,
        branchName: branches.name,
      })
      .from(pullRequests)
      .innerJoin(projects, eq(pullRequests.projectId, projects.id))
      .innerJoin(branches, eq(pullRequests.branchId, branches.id))
      .where(and(
        eq(pullRequests.id, prId),
        eq(projects.userId, userId)
      ))
      .limit(1);

    if (!pr) {
      return c.json({ error: 'Pull request not found' }, 404);
    }

    // Get GitHub token
    const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
    if (!token) {
      return c.json({ error: 'GitHub token not found' }, 401);
    }

    const repoFullName = `${pr.owner}/${pr.repoName}`;

    // Get PR details from GitHub
    const githubPr = await getPullRequest(token, repoFullName, pr.githubPrNumber);

    // Get check runs
    const checkRuns = await getCheckRuns(token, repoFullName, pr.branchName);

    // Get reviews
    const reviews = await getPullRequestReviews(token, repoFullName, pr.githubPrNumber);

    // Update status in database if changed
    const currentStatus = githubPr.merged
      ? 'merged'
      : githubPr.state === 'closed'
      ? 'closed'
      : 'open';

    if (currentStatus !== pr.status) {
      await db
        .update(pullRequests)
        .set({
          status: currentStatus,
          updatedAt: new Date(),
          mergedAt: githubPr.merged_at ? new Date(githubPr.merged_at) : null,
        })
        .where(eq(pullRequests.id, prId));
    }

    return c.json({
      id: prId,
      number: pr.githubPrNumber,
      title: githubPr.title,
      status: currentStatus,
      url: githubPr.html_url,
      state: githubPr.state,
      mergeable: githubPr.mergeable,
      mergeableState: githubPr.mergeable_state,
      draft: githubPr.draft,
      checks: {
        total: checkRuns.total_count,
        passed: checkRuns.check_runs.filter((c) => c.conclusion === 'success').length,
        failed: checkRuns.check_runs.filter((c) => c.conclusion === 'failure').length,
        pending: checkRuns.check_runs.filter((c) => c.status === 'in_progress').length,
        runs: checkRuns.check_runs.map((run) => ({
          name: run.name,
          status: run.status,
          conclusion: run.conclusion,
          url: run.html_url,
          startedAt: run.started_at,
          completedAt: run.completed_at,
        })),
      },
      reviews: reviews.map((review) => ({
        id: review.id,
        user: review.user?.login,
        state: review.state,
        body: review.body,
        submittedAt: review.submitted_at,
      })),
      createdAt: githubPr.created_at,
      updatedAt: githubPr.updated_at,
      closedAt: githubPr.closed_at,
      mergedAt: githubPr.merged_at,
    });

  } catch (error: any) {
    console.error('Error fetching PR status:', error);
    return c.json({ error: 'Failed to fetch PR status' }, 500);
  }
});

// ROUTES - PR DIFF

/**
 * GET /pull-requests/:prId/diff
 * Get PR file changes and diffs
 */
pullRequestsRouter.get('/:prId/diff', async (c) => {
  try {
    const prId = c.req.param('prId');
    const userId = c.get('userId');

    if (!userId) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const db = getDatabase(c.env.DB);

    // Get PR with project info
    const [pr] = await db
      .select({
        id: pullRequests.id,
        githubPrNumber: pullRequests.githubPrNumber,
        owner: projects.owner,
        repoName: projects.repoName,
      })
      .from(pullRequests)
      .innerJoin(projects, eq(pullRequests.projectId, projects.id))
      .where(and(
        eq(pullRequests.id, prId),
        eq(projects.userId, userId)
      ))
      .limit(1);

    if (!pr) {
      return c.json({ error: 'Pull request not found' }, 404);
    }

    // Get GitHub token
    const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
    if (!token) {
      return c.json({ error: 'GitHub token not found' }, 401);
    }

    const repoFullName = `${pr.owner}/${pr.repoName}`;

    // Get PR files with diffs
    const files = await getPullRequestFiles(token, repoFullName, pr.githubPrNumber);

    // Get stored changes from database
    const storedChanges = await db
      .select()
      .from(prChanges)
      .where(eq(prChanges.pullRequestId, prId));

    // Get risk flags
    const riskFlags = await db
      .select()
      .from(prRiskFlags)
      .where(eq(prRiskFlags.pullRequestId, prId))
      .orderBy(desc(prRiskFlags.level));

    return c.json({
      files: files.map((file) => ({
        path: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.changes,
        patch: file.patch,
        blobUrl: file.blob_url,
        rawUrl: file.raw_url,
        previousFilename: file.previous_filename,
      })),
      storedChanges,
      riskFlags,
      stats: {
        totalFiles: files.length,
        totalAdditions: files.reduce((sum, f) => sum + f.additions, 0),
        totalDeletions: files.reduce((sum, f) => sum + f.deletions, 0),
        totalChanges: files.reduce((sum, f) => sum + f.changes, 0),
      },
    });

  } catch (error: any) {
    console.error('Error fetching PR diff:', error);
    return c.json({ error: 'Failed to fetch PR diff' }, 500);
  }
});

// ROUTES - PR COMMENTS

/**
 * GET /pull-requests/:prId/comments
 * Get PR comments and review comments
 */
pullRequestsRouter.get('/:prId/comments', async (c) => {
  try {
    const prId = c.req.param('prId');
    const userId = c.get('userId');

    if (!userId) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const db = getDatabase(c.env.DB);

    const [pr] = await db
      .select({
        githubPrNumber: pullRequests.githubPrNumber,
        owner: projects.owner,
        repoName: projects.repoName,
      })
      .from(pullRequests)
      .innerJoin(projects, eq(pullRequests.projectId, projects.id))
      .where(and(
        eq(pullRequests.id, prId),
        eq(projects.userId, userId)
      ))
      .limit(1);

    if (!pr) {
      return c.json({ error: 'Pull request not found' }, 404);
    }

    const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
    if (!token) {
      return c.json({ error: 'GitHub token not found' }, 401);
    }

    const repoFullName = `${pr.owner}/${pr.repoName}`;

    // Get PR comments
    const comments = await getPullRequestComments(token, repoFullName, pr.githubPrNumber);

    // Get review comments
    const reviewComments = await getPullRequestReviewComments(token, repoFullName, pr.githubPrNumber);

    return c.json({
      comments: comments.map((c) => ({
        id: c.id,
        user: c.user?.login,
        body: c.body,
        createdAt: c.created_at,
        updatedAt: c.updated_at,
        url: c.html_url,
      })),
      reviewComments: reviewComments.map((rc) => ({
        id: rc.id,
        user: rc.user?.login,
        body: rc.body,
        path: rc.path,
        line: rc.line,
        createdAt: rc.created_at,
        url: rc.html_url,
        diffHunk: rc.diff_hunk,
      })),
      totals: {
        comments: comments.length,
        reviewComments: reviewComments.length,
      }
    });

  } catch (error: any) {
    console.error('Error fetching PR comments:', error);
    return c.json({ error: 'Failed to fetch PR comments' }, 500);
  }
});

// ROUTES - MERGE PR

/**
 * POST /pull-requests/:prId/merge
 * Merge a pull request
 */
pullRequestsRouter.post(
  '/:prId/merge',
  zValidator('json', mergePRSchema),
  async (c) => {
    try {
      const prId = c.req.param('prId');
      const { mergeMethod, commitTitle, commitMessage } = c.req.valid('json');
      const userId = c.get('userId');

      if (!userId) {
        return c.json({ error: 'Unauthorized' }, 401);
      }

      const db = getDatabase(c.env.DB);

      // Get PR with project info
      const [pr] = await db
        .select({
          id: pullRequests.id,
          githubPrNumber: pullRequests.githubPrNumber,
          status: pullRequests.status,
          branchId: branches.id,
          branchName: branches.name,
          owner: projects.owner,
          repoName: projects.repoName,
        })
        .from(pullRequests)
        .innerJoin(projects, eq(pullRequests.projectId, projects.id))
        .innerJoin(branches, eq(pullRequests.branchId, branches.id))
        .where(and(
          eq(pullRequests.id, prId),
          eq(projects.userId, userId)
        ))
        .limit(1);

      if (!pr) {
        return c.json({ error: 'Pull request not found' }, 404);
      }

      if (pr.status !== 'open') {
        return c.json({ error: `Pull request is already ${pr.status}` }, 400);
      }

      // Get GitHub token
      const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
      if (!token) {
        return c.json({ error: 'GitHub token not found' }, 401);
      }

      const repoFullName = `${pr.owner}/${pr.repoName}`;

      // Pre-merge checks
      const githubPr = await getPullRequest(token, repoFullName, pr.githubPrNumber);

      if (!githubPr.mergeable) {
        return c.json(
          {
            error: 'Pull request has conflicts and cannot be merged',
            mergeableState: githubPr.mergeable_state,
          },
          400
        );
      }

      // Check status checks
      const checkRuns = await getCheckRuns(token, repoFullName, pr.branchName);
      const failedChecks = checkRuns.check_runs.filter((c) => c.conclusion === 'failure');
      
      if (failedChecks.length > 0) {
        return c.json(
          {
            error: 'Some status checks have failed',
            failedChecks: failedChecks.map((c) => ({
              name: c.name,
              url: c.html_url,
            })),
          },
          400
        );
      }

      // Merge PR
      const mergeResult = await mergeGitHubPR(token, repoFullName, pr.githubPrNumber, {
        merge_method: mergeMethod,
        commit_title: commitTitle,
        commit_message: commitMessage,
      });

      const now = new Date();

      // Update database
      await db
        .update(pullRequests)
        .set({
          status: 'merged',
          mergedAt: now,
          updatedAt: now,
        })
        .where(eq(pullRequests.id, prId));

      // Optionally delete the branch
      try {
        await deleteBranch(token, repoFullName, pr.branchName);
        await db.delete(branches).where(eq(branches.id, pr.branchId));
      } catch (branchDeleteError) {
        console.warn('Failed to delete branch:', branchDeleteError);
      }

      return c.json({
        success: true,
        merged: true,
        sha: mergeResult.sha,
        message: mergeResult.message,
        mergedAt: now.toISOString(),
      });

    } catch (error: any) {
      console.error('Error merging PR:', error);
      
      if (error.message?.includes('405')) {
        return c.json({ error: 'Pull request is not mergeable' }, 405);
      }
      
      return c.json(
        { error: 'Failed to merge pull request', details: error.message },
        500
      );
    }
  }
);

/**
 * POST /pull-requests/:prId/close
 * Close a pull request without merging
 */
pullRequestsRouter.post('/:prId/close', async (c) => {
  try {
    const prId = c.req.param('prId');
    const userId = c.get('userId');

    if (!userId) {
      return c.json({ error: 'Unauthorized' }, 401);
    }

    const db = getDatabase(c.env.DB);

    const [pr] = await db
      .select({
        githubPrNumber: pullRequests.githubPrNumber,
        status: pullRequests.status,
        owner: projects.owner,
        repoName: projects.repoName,
      })
      .from(pullRequests)
      .innerJoin(projects, eq(pullRequests.projectId, projects.id))
      .where(and(
        eq(pullRequests.id, prId),
        eq(projects.userId, userId)
      ))
      .limit(1);

    if (!pr) {
      return c.json({ error: 'Pull request not found' }, 404);
    }

    if (pr.status !== 'open') {
      return c.json({ error: 'Pull request is already closed' }, 400);
    }

    const token = await getGitHubToken(db, userId, c.env.ENCRYPTION_KEY);
    if (!token) {
      return c.json({ error: 'GitHub token not found' }, 401);
    }

    const repoFullName = `${pr.owner}/${pr.repoName}`;

    // Close PR on GitHub
    await updatePullRequest(token, repoFullName, pr.githubPrNumber, {
      state: 'closed',
    });

    // Update database
    await db
      .update(pullRequests)
      .set({
        status: 'closed',
        updatedAt: new Date(),
      })
      .where(eq(pullRequests.id, prId));

    return c.json({ success: true, message: 'Pull request closed' });

  } catch (error: any) {
    console.error('Error closing PR:', error);
    return c.json({ error: 'Failed to close pull request' }, 500);
  }
});

export default pullRequestsRouter;
